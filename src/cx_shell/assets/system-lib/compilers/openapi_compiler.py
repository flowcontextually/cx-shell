#!/usr/bin/env python3
import json
import sys
from typing import Any, Dict

import yaml

# --- The Custom Contextually Pydantic Model Generator ---

TYPE_MAP = {
    "string": "str",
    "number": "float",
    "integer": "int",
    "boolean": "bool",
    "array": "List",
    "object": "Dict[str, Any]",
}
FORMAT_MAP = {"date-time": "datetime", "date": "date", "uuid": "UUID"}
PYTHON_KEYWORDS = {"in", "from", "for", "is", "while", "class"}


def log_to_stderr(message: str):
    """Writes a log message to stderr, prefixed for clarity."""
    print(f"contextual_compiler: {message}", file=sys.stderr)


def safe_name(name: str) -> str:
    """Ensures a name is a valid Python identifier."""
    if name in PYTHON_KEYWORDS:
        return f"{name}_"
    return name.replace("-", "_")


def generate_pydantic_code(spec: Dict[str, Any]) -> str:
    """The core of our custom generator. It takes an OpenAPI spec and returns a string containing the generated Pydantic models."""
    is_swagger_v2 = "swagger" in spec and spec["swagger"].startswith("2.")
    schemas = (
        spec.get("definitions")
        if is_swagger_v2
        else spec.get("components", {}).get("schemas", {})
    )
    if not schemas:
        raise ValueError("No schemas/definitions found in the specification.")

    code = [
        "# Generated by the Contextually Blueprint Compiler",
        "from __future__ import annotations",
        "from typing import Any, Dict, List, Optional",
        "from datetime import date, datetime",
        "from uuid import UUID",
        "from pydantic import BaseModel, Field",
        "\n",
    ]
    for schema_name, schema_def in schemas.items():
        class_name = safe_name(schema_name.strip())
        required_fields = set(schema_def.get("required", []))
        if schema_def.get("type") != "object" or "properties" not in schema_def:
            continue
        code.append(f"class {class_name}(BaseModel):")
        properties = schema_def.get("properties", {})
        if not properties:
            code.append("    pass\n")
            continue
        fields = []
        for prop_name, prop_def in properties.items():
            field_name = safe_name(prop_name)
            is_required = prop_name in required_fields
            python_type = "Any"
            if "$ref" in prop_def:
                python_type = f'"{safe_name(prop_def["$ref"].split("/")[-1])}"'
            elif "type" in prop_def:
                json_type = prop_def["type"]
                if json_type == "array":
                    items_def = prop_def.get("items", {})
                    item_type = "Any"
                    if "$ref" in items_def:
                        item_type = f'"{safe_name(items_def["$ref"].split("/")[-1])}"'
                    elif "type" in items_def:
                        item_type = TYPE_MAP.get(items_def["type"], "Any")
                    python_type = f"List[{item_type}]"
                else:
                    python_type = TYPE_MAP.get(json_type, "Any")
                    if prop_def.get("format") in FORMAT_MAP:
                        python_type = FORMAT_MAP[prop_def["format"]]
            field_type = (
                python_type if is_required else f"Optional[{python_type}] = None"
            )
            if field_name != prop_name:
                fields.append(
                    f'    {field_name}: {field_type} = Field(alias="{prop_name}")'
                )
            else:
                fields.append(f"    {field_name}: {field_type}")
        code.extend(fields if fields else ["    pass"])
        code.append("\n")
    return "\n".join(code)


def generate_ccl_blueprint(spec: Dict[str, Any]) -> str:
    """Generates the blueprint.cx.yaml content as a YAML string."""
    info = spec.get("info", {})
    if "servers" in spec and spec["servers"]:
        server_url = spec["servers"][0].get("url", "https://api.example.com")
    elif "host" in spec:
        scheme = spec.get("schemes", ["https"])[0]
        host = spec["host"]
        base_path = spec.get("basePath", "")
        server_url = f"{scheme}://{host}{base_path}"
    else:
        server_url = "https://api.example.com"
    blueprint = {
        # Add a placeholder ID to satisfy the ApiCatalog schema.
        # The real "ID" of a blueprint is its file path, but the Pydantic
        # model requires this field to be present.
        "id": f"blueprint:{info.get('title', 'untitled').lower().replace(' ', '-')}",
        "name": info.get("title", "Untitled API"),
        "version": info.get("version", "1.0.0"),
        "connector_provider_key": "rest-declarative",
        "auth_config": {"type": "none"},
        "browse_config": {"base_url_template": server_url, "action_templates": {}},
    }
    action_templates = {}
    for path, path_item in spec.get("paths", {}).items():
        for method, operation in path_item.items():
            if method.lower() not in ["get", "post", "put", "patch", "delete"]:
                continue
            if "operationId" not in operation:
                continue
            op_id = operation["operationId"]
            # Replace OpenAPI's {param} syntax with Jinja2's {{ param }} syntax
            api_endpoint = path.replace("{", "{{ ").replace("}", " }}")
            action = {"http_method": method.upper(), "api_endpoint": api_endpoint}
            # --- INTELLIGENT PAYLOAD CONSTRUCTOR ---
            body_schema_name = None
            if "requestBody" in operation:  # OpenAPI 3.x
                try:
                    ref = operation["requestBody"]["content"]["application/json"][
                        "schema"
                    ]["$ref"]
                    body_schema_name = safe_name(ref.split("/")[-1])
                except KeyError:
                    pass
            else:  # Swagger 2.0
                for param in operation.get("parameters", []):
                    if param.get("in") == "body" and "$ref" in param.get("schema", {}):
                        ref = param["schema"]["$ref"]
                        body_schema_name = safe_name(ref.split("/")[-1])
                        break
            if body_schema_name:
                action["payload_constructor"] = {
                    "_constructor": f"schemas.{body_schema_name}"
                }
            # --- END ---
            action_templates[op_id] = action
    blueprint["browse_config"]["action_templates"] = action_templates
    return yaml.dump(blueprint, sort_keys=False, indent=2, width=120)


if __name__ == "__main__":
    try:
        log_to_stderr("Contextually custom compiler started.")
        spec_content = json.load(sys.stdin)
        log_to_stderr("Generating Pydantic models with custom generator...")
        schemas_py = generate_pydantic_code(spec_content)
        log_to_stderr(f"Generated {len(schemas_py)} bytes of Python model code.")
        log_to_stderr("Generating Contextually blueprint...")
        blueprint_yaml = generate_ccl_blueprint(spec_content)
        log_to_stderr(f"Generated {len(blueprint_yaml)} bytes of YAML blueprint.")
        output = {"blueprint_yaml": blueprint_yaml, "schemas_py": schemas_py}
        print(json.dumps(output, indent=2))
        log_to_stderr("Compiler finished successfully.")
        sys.exit(0)
    except Exception as e:
        log_to_stderr(f"FATAL ERROR: {type(e).__name__} - {e}")
        print(f"Compiler failed: {e}", file=sys.stderr)
        sys.exit(1)
