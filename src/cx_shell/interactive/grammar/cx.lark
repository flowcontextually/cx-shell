?start: command_line
command_line: executable formatter?

executable: assignment | pipeline | single_executable
pipeline: single_executable ("|" single_executable)+
assignment: CNAME "=" executable

single_executable: single_command | variable_lookup | "(" executable ")"
variable_lookup: CNAME

single_command: dot_notation_kw_action
              | dot_notation_pos_action
              | builtin_command

builtin_command: connections_command
               | help_command
               | inspect_command
               | connect_command
               | session_command
               | variable_command
               | flow_command
               | query_command
               | script_command
               | connection_command
               | open_command
               | app_command
               | agent_command
               | process_command
               | compile_command

formatter: formatter_option+
formatter_option: output_option | columns_option | query_option
output_option: "--output" CNAME
columns_option: "--columns" column_list
query_option: "--query" STRING
column_list: CNAME ("," CNAME)*

# --- COMMAND DEFINITIONS ---
dot_notation_kw_action: CNAME "." CNAME "(" [arguments] ")"
dot_notation_pos_action: CNAME "." CNAME "(" STRING ")"
connect_command: "connect" ARG "--as" CNAME
connections_command: "connections"
help_command: "help"
inspect_command: "inspect" ARG
compile_command: "compile" named_argument+
agent_command: "agent" STRING

# --- Grouped Commands with Aliased Sub-Rules ---

session_command: "session" session_subcommand
session_subcommand: "list" -> session_list
                  | "status" -> session_status
                  | "save" ARG -> session_save
                  | "load" ARG -> session_load
                  | "rm" ARG -> session_rm

variable_command: ("var" | "vars") variable_subcommand
variable_subcommand: "list" -> variable_list
                   | "rm" ARG -> variable_rm

flow_command: "flow" flow_subcommand
flow_subcommand: "list" -> flow_list
               | "run" named_argument+ -> flow_run

query_command: "query" query_subcommand
query_subcommand: "list" -> query_list
                | "run" named_argument+ -> query_run

script_command: "script" script_subcommand
script_subcommand: "list" -> script_list
                | "run" named_argument+ -> script_run

connection_command: "connection" connection_subcommand
connection_subcommand: "list" -> connection_list
                     | "create" named_argument* -> connection_create

open_command: "open" (JINJA_BLOCK | ARG) [ARG] named_argument*

app_command: "app" app_subcommand
app_subcommand: "list" -> app_list
              | "install" named_argument+ -> app_install
              | "uninstall" ARG -> app_uninstall
              | "sync" -> app_sync
              | "package" ARG -> app_package
              | "search" [ARG] -> app_search

process_command: "process" process_subcommand
process_subcommand: "list" -> process_list
                  | "logs" ARG ["--follow"] -> process_logs
                  | "stop" ARG -> process_stop

# --- ARGUMENT & TERMINAL DEFINITIONS ---
arguments: (kw_argument ("," kw_argument)*)
kw_argument: CNAME "=" value

# Simplified rule for named arguments. The ARG terminal will capture all
# unquoted values, which are then parsed in the transformer.
named_argument: FLAG (STRING | ARG)

# Give FLAG a higher priority to ensure it's matched before the more generic ARG.
# This resolves the "--spec-url" vs. ARG ambiguity.
FLAG.1: /--[a-zA-Z0-9_-]+/

# `value` is for keyword arguments inside parentheses, like `gh.action(key=value)`.
# It does not need ARG, as unquoted values there are treated as CNAMEs (variable names).
value: STRING | NUMBER | "true" -> true | "false" -> false | "null" -> null | CNAME | JINJA_BLOCK

# ARG is for any unquoted, path-like or version-like string.
ARG: /[\/a-zA-Z0-9_:\-.~+@]+/
JINJA_BLOCK: /\{\{.*?\}\}/
STRING : /(\".*?\"|\'.*?\')/
%import common.SIGNED_NUMBER -> NUMBER
%import common.CNAME
%import common.WS
%ignore WS